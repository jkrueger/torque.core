;; -*- mode: clojure; eval: (paredit-mode 1);-*-
;;   Copyright (c) Rich Hickey. All rights reserved.
;;   The use and distribution terms for this software are covered by the
;;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;;   which can be found in the file epl-v10.html at the root of this distribution.
;;   By using this software in any fashion, you are agreeing to be bound by
;;   the terms of this license.
;;   You must not remove this notice, or any other, from this software.

(ns torque.lang.arrows
  (:use
    [torque.lang.protocols]
    [torque.lang.boot]
    [torque.lang.let]
    [torque.lang.def]
    [torque.lang.list]
    [torque.lang.seq]
    [torque.lang.predicates]))

(def ^:macro ->
  (fn -> [x & forms]
    (loop [cur x
           fs  forms]
      (if fs
        (let [form     (first fs)
              threaded (if (seq? form)
                         (with-meta `(~(first form) ~cur ~@(next form))
                           (meta form))
                         (list form cur))]
          (recur threaded (next fs)))
        cur))))

(def ^:macro ->>
  (fn ->> [x & forms]
    (loop [cur x
           fs  forms]
      (if fs
        (let [form     (first fs)
              threaded (if (seq? form)
                         (with-meta `(~(first form) ~@(next form) ~cur)
                           (meta form))
                         (list form cur))]
          (recur threaded (next fs)))
        cur))))

;; (def ^:macro cond->
;;   (fn cond-> [expr & clauses]
;; ;;    (assert (even? (count clauses)))
;;     (let [g (gensym)
;;           steps (map (fn [[test step]] `(if ~test (-> ~g ~step) ~g))
;;                      (partition 2 clauses))]
;;       `(let [~g ~expr
;;              ~@(interleave (repeat g) (butlast steps))]
;;          ~(if (empty? steps)
;;             g
;;             (last steps))))))

;; (def ^:macro cond->>
;;   (fn cond->> [expr & clauses]
;; ;;    (assert (even? (count clauses)))
;;     (let [g     (gensym)
;;           steps (map (fn [[test step]]
;;                        `(if ~test (->> ~g ~step) ~g))
;;                      (partition 2 clauses))]
;;       `(let [~g ~expr
;;              ~@(interleave (repeat g) (butlast steps))]
;;          ~(if (empty? steps)
;;             g
;;             (last steps))))))

(def ^:macro as->
  (fn [expr name & forms]
    `(let [~name ~expr
           ~@(interleave (repeat name) forms)]
       ~name)))

(def ^:macro some->
  (fn [expr & forms]
    (let [g     (gensym)
          pstep (fn [step] `(if (nil? ~g) nil (-> ~g ~step)))]
      `(let [~g ~expr
             ~@(interleave (repeat g) (map pstep forms))]
         ~g))))

(def ^:macro some->>
  (fn [expr & forms]
    (let [g     (gensym)
          pstep (fn [step] `(if (nil? ~g) nil (->> ~g ~step)))]
      `(let [~g ~expr
             ~@(interleave (repeat g) (map pstep forms))]
         ~g))))
