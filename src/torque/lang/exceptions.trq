;; -*- mode: clojure;-*-

(ns torque.lang.exceptions
  (:require
    [torque.lang.protocols :refer :all]
    [torque.lang.boot :refer :all]
    [torque.lang.string :refer :all]
    [torque.lang.symbol :refer :all]
    [torque.lang.cons :refer :all]
    [torque.lang.list :refer :all]))

(deftype ExceptionInfo [message data cause]

  IPrintable
  (-str [_]
    (str message "\n  " data)))

(def ex-info
  (fn* ex-info
    ([msg map]
     (new ExceptionInfo msg map nil))
    ([msg map cause]
     (new ExceptionInfo msg map cause))))

(def ex-message
  (fn* ex-message [ex]
    (if (instance? ExceptionInfo ex)
      (. ex message))))

(def ex-cause
  (fn* ex-cause
    [ex]
    (if (instance? ExceptionInfo ex)
      (. ex cause))))

(def ^:macro throw
  (fn* ex-throw [x]
    (list 'throw* x)))

(def ^:macro try
  (fn* [& body]
    (if body
      (let* [forms (loop* [xs    body
                           forms (list)]
                     (if (-next xs)
                       (recur (-next xs)
                              (cons (-first xs) forms))
                       [forms (-first xs)]))]
        ;; TODO: do try*/catch* once it's implemented
        (cons 'do (-nth forms 0))))))

;; TODO: add *assert* flag
;; (def ^:macro assert
;;   (fn* assert
;;     ([x]
;;      (if (not x)
;;        (throw
;;          (ex-info (str "Assertion error: " x)
;;                   {})))
;;     ([x msg]
;;      (if (not x)
;;        (throw
;;          (ex-info (str "Assertion error: "
;;                        ~msg "\n"
;;                        x)
;;                   {})))))))
