;; -*- mode: clojure;-*-

(ns torque.lang.boot
  (:require
    [torque.lang.protocols :refer :all]))

(def identical?
  (fn* identical? [x y] (torque.core.builtin/identical? x y)))

(def satisfies?
  (fn* satisfies? [x y] (torque.core.builtin/satisfies? x y)))

(def +
  (fn* + [a b] (torque.core.builtin/+ a b)))

(def -
  (fn* - [a b] (torque.core.builtin/- a b)))

(def *
  (fn* * [a b] (torque.core.builtin/* a b)))

(def /
  (fn* / [a b] (torque.core.builtin// a b)))

(def bit-and
  (fn* bit-and [a b] (torque.core.builtin/& a b)))

(def bit-or
  (fn* bit-or [a b] (torque.core.builtin/| a b)))

(def bit-shift-left
  (fn* bit-shift-left [a b] (torque.core.builtin/bsl a b)))

(def bit-shift-right
  (fn* bit-shift-right [a b] (torque.core.builtin/bsr a b)))

(def inc
  (fn* inc [x] (+ x 1)))

(def dec
  (fn* dec [x] (- x 1)))

(def <
  (fn* < [a b] (torque.core.builtin/< a b)))

(def >
  (fn* > [a b] (torque.core.builtin/> a b)))

(def <=
  (fn* <= [a b] (torque.core.builtin/<= a b)))

(def >=
  (fn* >= [a b] (torque.core.builtin/>= a b)))

(def ==
  (fn* == [a b] (torque.core.builtin/== a b)))

(def =
  (fn* = [a b]
    (if (identical? a b)
      true
      (if a
        (if b
          (if (satisfies? IEquiv a)
            (-equiv a b)
            false)
          false)
        false))))

(def integer?
  (fn* integer? [x]
    (if x
      (torque.core.builtin/integer? x)
      false)))

;; TODO: maybe have a ABinary type protocol ?
(def binary?
  (fn* binary? [x]
    (if x
      (if (satisfies? ICounted x)
        (satisfies? IPointerTarget x)
        false)
      false)))

(def array?
  (fn* array? [x]
    (if x
      (torque.core.builtin/array? x)
      false)))

(def type
  (fn* type [x] (torque.core.builtin/type x)))

(def instance?
  (fn* instance? [t x] (identical? (type x) t)))

(def make-binary
  (fn* make-binary [n] (torque.core.builtin/make-binary n)))

(def blength
  (fn* blength [b]
    (if (binary? b)
      (-count b)
      ;; TODO: throw
      nil)))

(def bget
  (fn* bget [b n]
    (if (binary? b)
      (if (< n (-count b))
        (torque.core.builtin/bget b n)
        ;; TODO: throw
        nil)
      ;; TODO: throw
      nil)))

(def bset
  (fn* bset [b n val]
    (if (binary? b)
      (if (< n (-count b))
        (torque.core.builtin/bset b n val)
        ;; FIXME: throw
        nil)
      ;; FIXME: throw
      nil)))

(def bcopy
  (fn* bcopy [dst src off len]
    (if (binary? dst)
      (if (binary? src)
        (if (<= (+ off len) (-count dst))
          (do
            (torque.core.builtin/mcopy
              (+ (-intptr dst) off)
              (-intptr src)
              len)
            dst)
          ;; FIXME: throw
          dst)
        ;; FIXME: throw
        dst)
      ;; FIXME: throw
      dst)))

(def bclone
  (fn* bclone [src]
    (let* [len (-count src)
           bin (make-binary len)]
      (bcopy bin src 0 len))))

(def make-array
  (fn* make-array [n] (torque.core.builtin/make-array n)))

;; (def acopy
;;   (fn* acopy [dst src off len]
;;     (torque.core.builtin/acopy dst src off len)))

(def aget
  (fn* aget [a n] (torque.core.builtin/aget a n)))

(def aset
  (fn* aset [a n v] (torque.core.builtin/aset a n v)))

(def alength
  (fn* alength [a] (torque.core.builtin/alength a)))

(def array
  (fn* array [& vs] vs))

(def acopy
  (fn* acopy [dst src off len]
    (loop* [n off]
      (if (< n len)
        (do
          (aset dst n (aget src n))
          (recur (inc n)))))
    dst))

(def aclone
  (fn* aclone [a]
    (acopy (make-array a) a 0 (alength a))))

(def ^:private io-size
  (fn* io-size [x]
    (if (binary? x)
      (-count x)
      (if (integer? x)
        1
        (if (satisfies? ISerializable x)
          (-count (-bytes x))
          ;; FIXME: throw
          0)))))

(def ^:private binary-size
  (fn* binary-size [xs]
    (let* [len (alength xs)]
      (loop* [out 0
              idx 0]
        (if (< idx len)
          (let* [x (aget xs idx)
                 s (io-size x)]
            (recur (+ out s) (inc idx)))
          out)))))

(def binary*
  (fn* binary* [xs]
    (let* [size (binary-size xs)
           bin  (make-binary size)
           len  (alength xs)]
      (loop* [pos 0
              idx 0]
        (if (< idx len)
          (let* [x (aget xs idx)
                 s (io-size x)]
            (if (binary? x)
              (bcopy bin x pos s)
              (if (integer? x)
                (bset bin pos x)
                (if (satisfies? ISerializable x)
                  (bcopy bin (-bytes x) pos s)
                  ;; FIXME: throw
                  nil)))
            (recur (+ pos s) (inc idx)))))
      bin)))

(def binary
  (fn* binary [& vs] (binary* vs)))

;; (def type?
;;   (fn* type? [x]
;;     (torque.core.builtin/type? x)))

(def nil?
  (fn* nil? [x] (identical? x nil)))

(def true?
  (fn* true? [x] (identical? x true)))

(def false?
  (fn* false? [x] (identical? x false)))

(def zero?
  (fn* zero? [x] (torque.core.builtin/== x 0)))

(def pos?
  (fn* pos? [x] (> x 0)))

(def neg?
  (fn* neg? [x] (< x 0)))

(def not
  (fn* not [x] (if x false true)))

(def seq
  (fn* seq [x]
    (if (not (nil? x))
      (if (satisfies? ISeqable x)
        (-seq x)
        nil)
      nil)))

(def bytes -bytes)

;; (def intptr
;;   (fn* intptr [x]
;;     (if (nil? x)
;;       0
;;       (if (integer? x)
;;         x
;;         (-intptr x)))))

(def with-meta
  (fn* [o meta]
    (if (not (nil? o))
      (if (satisfies? IMeta o)
        (-with-meta o meta)
        nil)
      nil)))

(def meta
  (fn* [o]
    (if (not (nil? o))
      (if (satisfies? IWithMeta o)
        (-meta o)
        nil)
      nil)))

(deftype Reduced [val]
  IDeref
  (-deref [o] val))

(def reduced
  (fn* reduced [x]
    (new Reduced x)))

(def reduced?
  (fn* reduced? [r]
    (instance? Reduced r)))

(def deref
  (fn* deref [o]
    (-deref o)))

;; FIXME: crutches for development. remove these later

(def print
  (fn* [x]
    (torque.core.builtin/print (-intptr x))))

;; (def read
;;   (fn* [x]
;;     (torque.core.builtin/read x)))
