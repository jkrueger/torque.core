;; -*- mode: clojure;-*-

(ns torque.lang.list
  (:use
    [torque.lang.protocols]
    [torque.lang.boot]
    [torque.lang.string]))

(deftype List [meta first rest count]

  ;; tag protocol to hide the fact that there
  ;; are different types that act as lists
  AList

  IPrintable
  (-str [this]
    ;; TODO: use extend to use a common implementation
    ;; with cons
    (str "("
         (loop* [s ""
                 f first
                 r (seq rest)]
                (if r
                  (recur (str s f " ")
                         (-first r)
                         (-next r))
                  (str s f)))
         ")"))

  ICloneable
  (-clone [_]
    (new List meta first rest count))

  IWithMeta
  (-with-meta [o meta]
    (new List meta first rest count))

  IMeta
  (-meta [o] meta)

  ISeq
  (-first [_]
    first)
  (-rest  [_]
    (if (= count 1)
      ()
      rest))

  INext
  (-next [_]
    (if (= count 1)
      nil
      rest))

  IStack
  (-peek [_]
    first)
  (-pop [coll]
    (-rest coll))

  ICollection
  (-conj [coll o]
    (new List meta o coll (inc count)))

  ;; IEquiv
  ;; (-equiv [o other]
  ;;   (seq/equiv o other))

  ISeqable
  (-seq [o] o)

  ICounted
  (-count [_] count)

  ;; IReduce
  ;; (-reduce [coll f init]
  ;;   (seq/reduce f init coll))
  )

(def empty-list
  (fn* []
    (new List nil nil nil 0)))

(def ^:private reverse
  (fn* [args]
    (loop* [out (empty-list)
            xs  args]
      (if (not (nil? xs))
        (recur (-conj out (-first xs))
               (-next xs))
        out))))

(def list
  (fn* list [& args]
    (reverse (reverse args))))
