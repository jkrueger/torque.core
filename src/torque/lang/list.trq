;; -*- mode: clojure;-*-

(ns torque.lang.list
  (:require
    [torque.lang.protocols :refer :all]
    [torque.lang.boot :refer :all]
    ;; [torque.lang.string :refer (str)]
    [torque.lang.common.seq :as seq]))

(deftype List [meta first rest count]

  ;; tag protocol to hide the fact that there
  ;; are different types that act as lists
  AList

  IPrintable
  (-str [this]
    ;; TODO: use extend to use a common implementation
    ;; with cons
    ;; (str "("
    ;;      (loop* [s ""
    ;;              f first
    ;;              r (seq rest)]
    ;;             (if r
    ;;               (recur (str s f " ")
    ;;                      (-first r)
    ;;                      (-next r))
    ;;               (str s f)))
    ;;      ")")
    "List")

  ICloneable
  (-clone [_]
    (new List meta first rest count))

  IWithMeta
  (-with-meta [o meta]
    (new List meta first rest count))

  IMeta
  (-meta [o] meta)

  ISeq
  (-first [_]
    first)
  (-rest  [_]
    (if (= count 1)
      ()
      rest))

  INext
  (-next [_]
    (if (= count 1)
      nil
      rest))

  IStack
  (-peek [_]
    first)
  (-pop [coll]
    (-rest coll))

  ICollection
  (-conj [coll o]
    (new List meta o coll (inc count)))

  IEquiv
  (-equiv [o other]
    (seq/equiv o other))

  ISeqable
  (-seq [o] o)

  ICounted
  (-count [_] count)

  IReduce
  (-reduce [coll f]
    (seq/reduce f coll))
  (-reduce [coll f init]
    (seq/reduce f init coll)))

(def empty-list
  (fn* []
    (new List nil nil nil 0)))

(def list
  (fn* list [& xs]
    (loop* [out (empty-list)
            n   (alength xs)]
      (if (<= 0 n)
        (recur (-conj out (aget xs n))
               (dec n))
        out))))
