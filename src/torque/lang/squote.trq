;; -*- mode: clojure; eval: (paredit-mode 1);-*-
;;   Copyright (c) Rich Hickey. All rights reserved.
;;   The use and distribution terms for this software are covered by the
;;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;;   which can be found in the file epl-v10.html at the root of this distribution.
;;   By using this software in any fashion, you are agreeing to be bound by
;;   the terms of this license.
;;   You must not remove this notice, or any other, from this software.

(ns torque.lang.squote
  (:require
    [torque.lang.protocols :refer :all]
    [torque.lang.boot :refer :all]
    [torque.lang.cons :refer :all]
    [torque.lang.seq :refer :all]
    [torque.lang.chunked :refer :all]
    [torque.lang.lazy :refer :all]))

;; This is in its own namespace, since providing apply and concat enables
;; syntax quotes, which are then used in all the code past this point

(defn ^:private collect [xs]
  (if-let [ys (next xs)]
    (cons (first xs) (collect ys))
    (seq (first xs))))

(defn applier
  ([f xs]
   (let [x0 (first xs)
         n  (next xs)]
     (if (nil? n)
       (f x0)
       (applier f x0 n))))
  ([f x0 xs]
   (let [x1 (first xs)
         n  (next xs)]
     (if (nil? n)
       (f x0 x1)
       (applier f x0 x1 n))))
  ([f x0 x1 xs]
   (let [x2 (first xs)
         n  (next xs)]
     (if (nil? n)
       (f x0 x1 x2)
       (applier x0 x1 x2 n))))
  ([f x0 x1 x2 xs]
   (let [x3 (first xs)]
     (f x0 x1 x2 x3))))

(defn apply [f & args]
  (applier f (collect (array-seq args))))

(defn ^:private cat [xys zs]
  (lazy-seq
    (let [s (seq xys)]
      (if s
        (if (chunked-seq? s)
          (chunk-cons (chunk-first s) (cat (chunk-rest s) zs))
          (cons (first s) (cat (rest s) zs)))
        (when zs
          (cat (first zs) (next zs)))))))

(defn concat
  ([]
   (lazy-seq nil))
  ([x]
   (lazy-seq x))
  ([x y]
   (lazy-seq
     (let [s (seq x)]
       (if s
         (if (chunked-seq? s)
           (chunk-cons (chunk-first s) (concat (chunk-rest s) y))
           (cons (first s) (concat (rest s) y)))
         y))))
  ([x y & zs]
   (cat (concat x y) zs)))
