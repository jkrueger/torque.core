;; -*- mode: clojure;-*-

(ns torque.lang.predicates
  (:require
    [torque.lang.protocols :refer :all]
    [torque.lang.boot :refer :all]
    [torque.lang.def :refer :all]
    [torque.lang.flow :refer :all]
    [torque.lang.let :refer :all]
    [torque.lang.indexed :refer :all]
    [torque.lang.vector :refer :all]
    [torque.lang.squote :refer :all]))

(defn boolean [x]
  (if x true false))

(defn number? [x]
  (integer? x))

(defn pointer? [x]
  (integer? x))

(defn coll? [x]
  (satisfies? ICollection x))

(defn set? [x]
  (satisfies? ISet x))

(defn associative? [x]
  (satisfies? IAssociative x))

(defn sorted? [x]
  (satisfies? ISorted x))

(defn seqable? [x]
  (satisfies? ISeqable x))

(defn reduceable? [x]
  (satisfies? IReduce x))

(defn list? [x]
  (satisfies? AList x))

(defn map? [x]
  (satisfies? IMap x))

(defn set? [x]
  (satisfies? ISet x))

(defn chunked-seq? [x]
  (satisfies? IChunkedSeq x))

(defn record? [x]
  (satisfies? IRecord x))

(defn indexed? [x]
  (satisfies? IIndexed x))

(defn counted? [x]
  (satisfies? ICounted x))

(defn printable? [x]
  (satisfies? IPrintable x))

(defmacro and
  ([]  true)
  ([x] x)
  ([x & xs]
   `(let [and# ~x]
      (if and# (and ~@xs) and#))))

(defmacro or
  ([]  nil)
  ([x] x)
  ([x & xs]
   `(let [or# ~x]
      (if or# or# (or ~@xs)))))

(defn named? [x]
  (or (satisfies? INamed x) (string? x)))

(defmacro not= [a b]
  `(not (= ~a ~b)))

(defn has-meta? [x]
  (and (satisfies? IMeta x) (satisfies? IWithMeta x)))

(defn boolean? [x]
  (and (not (nil? x)) (or (identical? x true) (identical? x false))))

(defn even? [x]
  (== (bit-and x 0x1) 0))

(defn odd? [x]
  (== (bit-and x 0x1) 0x1))

(defn complement
  [f]
  (fn
    ([] (not (f)))
    ([x] (not (f x)))
    ([x y] (not (f x y)))
    ([x y & zs] (not (apply f x y (array-seq zs))))))

(defn every?
  [pred coll]
  (cond
    (nil? (seq coll))
      true
    (pred (first coll))
      (every? pred (next coll))
    :else
      false))

(defn some
  [pred coll]
  (loop [coll coll]
    (when (seq coll)
      (or (pred (first coll))
          (recur (next coll))))))
