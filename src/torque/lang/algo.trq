;; -*- mode: clojure; eval: (paredit-mode 1);-*-
;;   Copyright (c) Rich Hickey. All rights reserved.
;;   The use and distribution terms for this software are covered by the
;;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;;   which can be found in the file epl-v10.html at the root of this distribution.
;;   By using this software in any fashion, you are agreeing to be bound by
;;   the terms of this license.
;;   You must not remove this notice, or any other, from this software.

(ns torque.lang.algo
  (:use
    [torque.lang.protocols]
    [torque.lang.boot]
    [torque.lang.cons]
    [torque.lang.list]
    [torque.lang.flow]
    [torque.lang.let]
    [torque.lang.def]
    [torque.lang.lazy]
    [torque.lang.seq]
    [torque.lang.indexed]
    [torque.lang.chunked]
    [torque.lang.vector]
    [torque.lang.squote]
    [torque.lang.predicates])
  (:require
    [torque.lang.common.seq :as seq]))

(defn identity [x]
  x)

(declare comp)

;; (defn comp
;;   ([] identity)
;;   ([f] f)
;;   ([f g]
;;    (fn
;;      ([] (f (g)))
;;      ([x] (f (g x)))
;;      ([x y] (f (g x y)))
;;      ([x y z] (f (g x y z)))
;;      ([x y z & args] (f (apply g x y z args)))))
;;   ([f g & fs]
;;    (seq/reduce comp (list* f g fs))))

(defn not-empty
  [coll] (when (seq coll) coll))

(defn count [coll]
  (if-not (nil? coll)
    (if (satisfies? ICounted coll)
      (-count coll)
      (if (array? coll)
        (alength coll)
        (seq/count coll)))
    0))

(defn conj
  ([]       [])
  ([coll]   coll)
  ([coll x] (-conj coll x))
  ([coll & args]
    (loop [out coll
           xs  args]
      (if xs
        (let [val (-first xs)]
          (recur (conj out val) (next xs)))
        out))))

;; (defn filter
;;   ([pred]
;;    (fn [rf]
;;      (fn
;;        ([] (rf))
;;        ([result] (rf result))
;;        ([result input]
;;         (if (pred input)
;;           (rf result input)
;;           result)))))
;;   ([pred coll]
;;    (lazy-seq
;;     (when-let [s (seq coll)]
;;       (if (chunked-seq? s)
;;         (let [c (chunk-first s)
;;               size (count c)
;;               b (chunk-buffer size)]
;;           (dotimes [i size]
;;             (when (pred (-nth c i))
;;               (chunk-append b (-nth c i))))
;;           (chunk-cons (chunk b) (filter pred (chunk-rest s))))
;;         (let [f (first s) r (rest s)]
;;           (if (pred f)
;;             (cons f (filter pred r))
;;             (filter pred r))))))))

;; (defn remove
;;   ([pred]
;;    (filter (complement pred)))
;;   ([pred coll]
;;    (filter (complement pred) coll)))

(defn map
  ([f coll]
   (lazy-seq
    (when-let [s (seq coll)]
      (if (chunked-seq? seq)
        (let [c    (chunk-first s)
              size (count c)
              b    (chunk-buffer size)]
          (loop [i 0]
            (when (< i size)
              (chunk-append b (f (-nth c i)))
              (recur (inc i))))
          (chunk-cons (chunk b) (map f (chunk-rest s))))
        (cons (f (first s)) (map f (rest s)))))))
  ([f c1 c2]
   (lazy-seq
    (let [s1 (seq c1)
          s2 (seq c2)]
      (when (and s1 s2)
        (cons (f (first s1) (first s2))
              (map f (rest s1) (rest s2))))))))

(defn mapcat
  ([f]
   (comp (map f) cat))
  ([f & colls]
   (apply concat (apply map f colls))))

;; (defn zipmap
;;   [keys vals]
;;   (loop [map {}
;;          ks  (seq keys)
;;          vs  (seq vals)]
;;     (if (and ks vs)
;;       (recur (assoc map (first ks) (first vs))
;;              (next ks)
;;              (next vs))
;;       map)))

(defn reduce
  ([f coll]
   (if (satisfies? IReduce coll)
     (-reduce coll f)
     (seq/reduce f coll)))
  ([f val coll]
   (if (satisfies? IReduce coll)
     (-reduce coll f val)
     (seq/reduce f val coll))))

(declare persistent! transient)

(defn into
  ([to from]
   (if-not (nil? to)
     (if (satisfies? IEditableCollection to)
       (with-meta (persistent! (reduce -conj! (transient to) from)) (meta to))
       (reduce -conj to from))
     (reduce conj () from))))

(defn mapv
  ([f coll]
   (reduce (fn [v o] (conj v (f o))) [] coll))
  ([f c1 c2]
   (into [] (map f c1 c2)))
  ([f c1 c2 c3]
   (into [] (map f c1 c2 c3)))
  ([f c1 c2 c3 & colls]
   (into [] (apply map f c1 c2 c3 colls))))

(defn butlast [s]
  (loop [ret [] s s]
    (if (next s)
      (recur (conj ret (first s)) (next s))
      (seq ret))))

(defn take [n coll]
  (lazy-seq
   (when (pos? n)
     (when-let [s (seq coll)]
       (cons (first s) (take (dec n) (rest s)))))))

(defn take-while [pred coll]
  (lazy-seq
   (when-let [s (seq coll)]
     (when (pred (first s))
       (cons (first s) (take-while pred (rest s)))))))

(defn drop [n coll]
  (let [step (fn [n coll]
               (let [s (seq coll)]
                 (if (and (pos? n) s)
                   (recur (dec n) (rest s))
                   s)))]
    (lazy-seq (step n coll))))

(defn drop-while [pred coll]
  (let [step (fn [pred coll]
               (let [s (seq coll)]
                 (if (and s (pred (first s)))
                   (recur pred (rest s))
                   s)))]
    (lazy-seq (step pred coll))))

(defn split-at
  [n coll]
  [(take n coll) (drop n coll)])

(defn repeat
  ([x]
   (lazy-seq (cons x (repeat x))))
  ([n x]
   (take n (repeat x))))

(defn replicate
  [n x]
  (take n (repeat x)))

(defn iterate [f x]
  (cons x (lazy-seq (iterate f (f x)))))

(defn partition
  ([n coll]
     (partition n n coll))
  ([n step coll]
     (lazy-seq
       (when-let [s (seq coll)]
         (let [p (take n s)]
           (when (== n (count p))
             (cons p (partition n step (drop step s))))))))
  ([n step pad coll]
     (lazy-seq
       (when-let [s (seq coll)]
         (let [p (take n s)]
           (if (== n (count p))
             (cons p (partition n step pad (drop step s)))
             (list (take n (concat p pad)))))))))

(defn partition-by
  [f coll]
  (lazy-seq
   (when-let [s (seq coll)]
     (let [fst (first s)
           fv (f fst)
           run (cons fst (take-while (fn [x] (= fv (f x))) (next s)))]
       (cons run (partition-by f (seq (drop (count run) s))))))))

(defn fnil
  ([f x]
   (fn
     ([a]
      (f (if (nil? a) x a)))
     ([a b]
      (f (if (nil? a) x a) b))
     ([a b c]
      (f (if (nil? a) x a) b c))
     ([a b c & ds]
      (apply f (if (nil? a) x a) b c ds))))
  ([f x y]
   (fn
     ([a b]
      (f (if (nil? a) x a) (if (nil? b) y b)))
     ([a b c]
      (f (if (nil? a) x a) (if (nil? b) y b) c))
     ([a b c & ds]
      (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))
  ([f x y z]
   (fn
     ([a b]
      (f (if (nil? a) x a) (if (nil? b) y b)))
     ([a b c]
      (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))
     ([a b c & ds]
      (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))

;; (defn select-keys
;;   [map keyseq]
;;     (loop [ret {} keys (seq keyseq)]
;;       (if keys
;;         (let [key   (first keys)
;;               entry (get map key ::not-found)]
;;           (recur
;;            (if (not= entry ::not-found)
;;              (assoc ret key entry)
;;              ret)
;;            (next keys)))
;;         (with-meta ret (meta map)))))

(defn max [& xs]
  (loop [xs  xs
         res nil]
    (if-let [x (first xs)]
      (recur (next xs)
             (if (> (or res 0) x)
               res
               x))
      res)))
